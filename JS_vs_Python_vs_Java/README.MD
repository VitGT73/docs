# Сравнительная таблица Python vs JS/TS vs Java



### Приведение к типу

Начнем с приведения строки к целому. В Питоне все просто и прямолинейно:


```Python
number = int(text)
# или полная версия
number = int(text, base=10)
```

Но в JS вы должны объяснить к какой системе вы собираетесь приводить — к десятеричной, восьмеричной, шестнадцатеричной или двоичной:


```js
number = parseInt(text, 10);
```

Для использования обычной десятеричной системы мы передаем 10 в виде второго аргумента функции parseInt(). 8 для восьмеричной, 16 для шестнадцатеричной или 2 — для двоичной. В случае если второй параметр опущен, число начинается с нуля и вы используете устаревший браузер, строка с текстом будет воспринята как восьмеричная система:

```js
parseInt('012') == 10  // в некоторых старых браузерах
parseInt('012', 10) == 12
```

### Условное присваивание

Хотя для этого Python и JS используют различный синтаксис, данная операция популярна в обоих языках. Популярна она потому, что в одном выражении можно присвоить различные значения как для True-, так и для False-случая.
Начиная с Python 2.7 условное присваивание выглядит так:


```Python
value = 'YES' if positive == True else 'NO'
```

В JavaScript условное присваивание производится с использованием тернарного оператора ?, также как в C, C++, C#, Java, Ruby, PHP, Perl, Swift, and ActionScript:


```js
value = positive === true? 'YES': 'NO';
```

### Доступ к свойству объекта по имени свойства

Обычный способ доступа к свойству объекта и в Python и в JS одинаковый:


```Python
obj.color = 'YELLOW'
```

А как быть если название свойства заключено в строчную переменную? К примеру, название свойства может быть получено из списка свойств или название свойства составлено из двух строковых переменных: ```"title" + land_code.```
В Питоне для этого существуют функции ``getattr()`` и ``setattr()``:


```Python
attribute = 'color'
value = getattr(obj, attribute, 'GREEN')
setattr(obj, attribute, value)
```

В JS вы можете обращаться с объектом как со словарем и передавать имя свойства в квадратных скобках:


```js
attribute = 'color';
value = obj[attribute] || 'GREEN';
obj[attribute] = value;
```

Чтобы получить значение по умолчанию в случае если свойства с таким именем не существует, в Питоне у функции `getattr()` есть для этого третий параметр. В JS, если запрашиваемое свойство отсутствует, функция вернет `undefined`. Его можно сравнить оператором `OR` со значением по дефолту – это стандартная практика в JS — такой способ можно встретить во многих фреймворках и библиотеках.


### Доступ к словарю по ключу

Схоже с вышеизложенным. Ключ стандартно указывается в квадратных скобках в обоих языках:


```Python
dictionary = {}
dictionary['color'] = 'YELLOW'
```

Для доступа по ключу в Питоне используется стандартный синтаксис с квадратными скобками, однако в случае если такой ключ отсутствует это вызовет исключение с ошибкой `KeyError`.
Более гибким является метод `get()` который вернет None в случае отсутствия ключа. Также можно передать значение которое будет возвращено в случае отсутствия ключа:

```Python
key = 'color'
value = dictionary.get(key, 'GREEN')
```

В JS вы можете проделать такой же трюк как со свойством объекта – `OR` со значением по дефолту:


```js
key = 'color';
value = dictionary[key] || 'GREEN';
// Возможно лучше проверить по другому, чтобы исключить случай, когда key равен нулю или пустому значению
value = key in dictionary ?  dictionary[key] : 'GREEN';

```

### Срезы: списки и строки

У Питона есть оператор `[:]` получения части списка, кортежа или схожих структур. Пример с объектом типа `Django QuerySets`:


```Python
items = [1, 2, 3, 4, 5]
first_two = items[:2]      # [1, 2]
last_two = items[-2:]      # [4, 5]
middle_three = items[1:4]  # [2, 3, 4]
```

У JS есть метод `slice()` с тем же эффектом:


```js
items = [1, 2, 3, 4, 5];
first_two = items.slice(0, 2);     // [1, 2]
last_two = items.slice(-2);        // [4, 5]
middle_three = items.slice(1, 4);  // [2, 3, 4]
```

Но не путайте с методом `splice()` который изменяет исходный массив!


В Питоне оператор [:] также применим и к строкам:


```Python
text = 'ABCDE'
first_two = text[:2]      # 'AB'
last_two = text[-2:]      # 'DE'
middle_three = text[1:4]  # 'BCD'
```

В JS у строк также есть метод `slice()`:


```js
text = 'ABCDE';
first_two = text.slice(0, 2);    // 'AB'
last_two = text.slice(-2);       // 'DE'
middle_three = text.slice(1, 4); // 'BCD'
```

### Операции со списками

В программировании часто приходится собирать и анализировать последовательность элементов. В Питоне для этого обычно используют списки, а в Javascript — массивы. У них схожий синтаксис и операции, но различаются методы добавления и удаления элементов.


Соединяем два списка, добавляем один элемент в конец, добавляем один элемент в начало, получаем и удаляем элемент в начале, получаем и удаляем элемент с конца и удаляем конкретный элемент по индексу.

#### Python:


```Python
items1 = ['A']
items2 = ['B']
items = items1 + items2  # items == ['A', 'B']
items.append('C')        # ['A', 'B', 'C']
items.insert(0, 'D')     # ['D', 'A', 'B', 'C']
first = items.pop(0)     # ['A', 'B', 'C']
last = items.pop()       # ['A', 'B']
items.delete(0)          # ['B']
```

#### То же в Javascript:


```js
items1 = ['A'];
items2 = ['B'];
items = items1.concat(items2);  // items === ['A', 'B']
items.push('C');                // ['A', 'B', 'C']
items.unshift('D');             // ['D', 'A', 'B', 'C']
first = items.shift();          // ['A', 'B', 'C']
last = items.pop();             // ['A', 'B']
items.splice(0, 1);             // ['B']
```

### Соединяем наборы строк

Соединить набор строковых элементов в единую строку используя пробел, запятую или перевод строки в виде соединительного символа.


В Питоне для этого служит строковый метод join() который принимает в виде аргумента список или кортеж. Для непосвященного (в синтаксис Питона) может показаться странным начинать выражение с разделителя, но, после регулярного применения вы привыкнете к такой форме записи:


```Python
items = ['A', 'B', 'C']
text = ', '.join(items)  # 'A, B, C'
```

В JS у массивов есть метод `join()` с разделителем в виде аргумента:


```js
items = ['A', 'B', 'C'];
text = items.join(', ');  // 'A, B, C'
```

### JSON

При работе со многими API удобно сериализовать объекты в JSON-объекты для удобства передачи и последующего разбора.


В Питоне есть стандартный модуль json:


```Python
import json
json_data = json.dumps(dictionary, indent=4)
dictionary = json.loads(json_data)
```

Здесь мы форматируем JSON с помощью отступов в 4 пробела.


В JS существует объект JSON с методами для создания и парсинга JSON-строк:


```js
json_data = JSON.stringify(dictionary, null, 4);
dictionary = JSON.parse(json_data);
```

### Разбираем строки регулярками

В прошлой статье мы соединяли несколько строк в одну. Но как разделить одну длинную строку на несколько, особенно если разделителем выступает не один символ типа запятой, а целый диапазон различных вариантов? Здесь нам на помощь приходят регулярные выражения и метод `split()`.


В Питоне метод `split()` относится к шаблону регулярных выражений. Вот как можно разделить текстовую строку на предложения по знакам препинания:


import re

```Python
# Один или более символов "!?." за которыми следует ноль или более пробельных символов
delimiter = re.compile(r'[!?\.]+\s*')

text = "Hello!!! What's new? Follow me."
sentences = delimiter.split(text)
# sentences == ['Hello', "What's new", 'Follow me', '']
```

В JS метод ``split()`` относится к строкам:


```js
// Один или более символов "!?." за которыми следует ноль или более пробельных символов
delimiter = /[!?\.]+\s*/;

text = "Hello!!! What's new? Follow me.";
sentences = text.split(delimiter)
// sentences === ["Hello", "What's new", "Follow me", ""]
```

### Поиск регулярками по шаблону

Регулярные выражения часто используются для валидации данных из форм.
К примеру, для проверки корректности веденного e-mail адреса его надо сопоставить с шаблоном регулярного выражения.


В Питоне это будет выглядеть примерно так:

```Python
import re

# name, "@", and domain
pattern = re.compile(r'([\w.+\-]+)@([\w\-]+\.[\w\-.]+)')

match = pattern.match('hi@example.com')
# match.group(0) == 'hi@example.com'
# match.group(1) == 'hi'
# match.group(2) == 'example.com'
```

Если участок текста совпадает с шаблоном, то при помощи метода `group()` возвращается совпавший участок целиком в котором можно выделить отдельные группы определенные в шаблоне.


0 — совпавшая (под)строка целиком, 1 — первая группа, 2 — вторая и т.д.


Если совпадений не найдено, вернется объект типа `None`.


В JS существует строковый метод `match()`, который возвращает либо совпавший участок строки либо `null`.


```js
// name, "@", and domain
pattern = /([\w.+\-]+)@([\w\-]+\.[\w\-.]+)/;

match = 'hi@example.com'.match(pattern);
// match[0] === 'hi@example.com'
// match[1] === 'hi'
// match[2] === 'example.com'
```

В JS совпавший объект выглядит как массив. Элемент с индексом [0] — совпавшая (под)строка целиком, 1-й элемент — первая группа, 2-й — вторая и т.д. — все в соответствии с группами определенными в шаблоне.


Иногда кроме поиска требуется определить положение образца в тексте. Это можно сделать с помощью метода `search()`.
В Питоне этот метод относится к регулярным выражениям и возвращает совпавший объект. У этого совпавшего объекта есть метод `start()`, возвращающий начало вхождения этой подстроки в основную строку:


```Python
text = 'Say hi at hi@example.com'
first_match = pattern.search(text)
if first_match:
    start = first_match.start()  # start == 10
```

В JS метод есть строковый метод `search()` возвращающий индекс начала подстроки. Или -1 если совпадений не было найдено.



```js
text = 'Say hi at hi@example.com';
first_match = text.search(pattern);
if (first_match > -1) {
    start = first_match;  // start === 10
}
```

### Замена по шаблону с помощью регулярных выражений

Обычно замена по шаблону нужна когда требуется очистить данные или добавить какие-нибудь свойства в текст. К примеру, мы можем взять строку и все встречающиеся email-адреса сделать ссылками:


В Питоне для этого есть метод шаблона регулярных выражений `sub()`:



```Python
html = pattern.sub(
    r'<a href="mailto:\g<0>">\g<0></a>',
    'Say hi at hi@example.com',
)
# html == 'Say hi at <a href="mailto:hi@example.com">hi@example.com</a>'
```

Разработчики на JS могут использовать строковый метод `replace()`:


```js
html = 'Say hi at hi@example.com'.replace(
    pattern,
    '<a href="mailto:$&">$&</a>',
);
// html === 'Say hi at <a href="mailto:hi@example.com">hi@example.com</a>'
```

В Питоне совпавшие группы доступны как `\g<0>, \g<1>, \g<2>` и т.д.
В JS аналогично `$&, $1, $2` и т.д.


Также возможно заменить совпавший участок при помощи функции. Такие функции бывают полезны при замене оборачивании исходного текста или для подсчета, сбора или получения другой информации о тексте. К примеру, использую при замене вызов функции можно написать подсветку синтаксиса HTML.


Давайте изменим все встречающиеся e-mail адреса ПРОПИСНЫМИ БУКВАМИ.


В Питоне функция замены получает совпавший объект. Мы используем метод group() чтобы произвести действия с совпавшим текстом и вернуть его в виде замены:


```Python
text = pattern.sub(
    lambda match: match.group(0).upper(),
    'Say hi at hi@example.com',
)
# text == 'Say hi at HI@EXAMPLE.COM'
```

В JS функция замены получает совпавшую строку целиком, первое вхождение, второе и т.д. Мы производим необходимые действия и возвращаем измененную строку:


```js
text = 'Say hi at hi@example.com'.replace(
    pattern,
    function(match, p1, p2) {
        return match.toUpperCase();
    }
);
// text === 'Say hi at HI@EXAMPLE.COM'
```

### Обработка ошибок

В противоположность Питону фронтенд-браузерный JavaScript обычно не используют для записи-чтения файлов или доступа к базам данных. Поэтому блоки `try..catch` довольно редко встречаются в JS по сравнению с блоками `try..except` в Питоне.


Но, в любом случае, обработка ошибок может быть произведена в пользовательском скрипте, вызвана из библиотечной функции и перехвачена в основном коде.


В следующем примере на Питоне мы определим свое исключение `MyException`, порождаем его в функции, и посмотрим как его перехватить и обработать в блоке `try..except..finally`:


```Python
class MyException(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return self.message

def proceed():
    raise MyException('Error happened!')

try:
    proceed()
except MyException as err:
    print('Sorry! {}'.format(err))
finally:
    print('Finishing')
```

Следующий код на JS делает то же самое — мы определяем класс `MyException`, порождаем его в функции, перехватываем и обрабатываем в блоке `try..catch..finally`:


```js
function MyException(message) {
   this.message = message;
   this.toString = function() {
       return this.message;
   }
}

function proceed() {
    throw new MyException('Error happened!');
}

try {
    proceed();
} catch (err) {
    if (err instanceof MyException) {
        console.log('Sorry! ' + err);
    }
} finally {
    console.log('Finishing');
}
```
В обоих языках класс `MyException` имеет параметр message и метод для строкового представления в зависимости от значения `message`.


Конечно, исключения должны вызваться/порождаться только в случае ошибки. И если вы определили эту ошибку в своем модуле.


### Переменные в строках

Традиционный способ построения строк с переменными использует конкатенацию строк и переменных:


```Python
name = 'World'
value = 'Hello, ' + name + '!\nWelcome!'
```

Такая запись может показаться разбросанной и плохочитаемой, также часто можно ошибиться в пробелах окружающих слова в строках.


Начиная с версии 3.6 в Питоне и в JS ECMAScrip6 вы можете использовать строковую интерполяцию, или, в терминах Питона — f-строки. Это строковые шаблоны в которых подставляются значения из переменных.


В Питоне f-строки помечаются символом f перед кавычками:


```Python
name = 'World'
value = f"""Hello, {name}!
Welcome!"""

price = 14.9
value = f'Price: {price:.2f} €'  # 'Price: 14.90 €'
```

В JS строковые шаблоны начинаются и кончаются обратной кавычкой (backtrick) `

```js
name = 'World';
value = `Hello, ${name}!
Welcome!`;

price = 14.9;
value = `Price ${price.toFixed(2)} €`;  // 'Price: 14.90 €'
```
Заметим, что шаблоны могут быть как одно- итак и многострочными.
В Питоне можно задать форматирование переменных.


### Распаковка списков

В Питоне, а теперь уже и в JS существует интересная возможность присвоить элементы последовательности различным переменным. К примеру, мы можем присвоить трем переменным три значения из списка:

```Python
[a, b, c] = [1, 2, 3]
```
Для кортежей скобки могут быть опущены.
Следующий пример очень популярен в Питоне как способ обмена значений двух переменных:

```Python
a = 1
b = 2
a, b = b, a   # поменяли значения
```
В JS6+ также возможно:

```js
a = 1;
b = 2;
[a, b] = [b, a];  // поменяли значения
```
В Питоне, в случае если у нас есть неопределенное количество элементов в списке или кортеже, мы можем присвоить эти элементы кортежу из переменных в котором последние несколько значений вернуться как список:

```Python
first, second, *the_rest = [1, 2, 3, 4]
# first == 1
# second == 2
# the_rest == [3, 4]
```
Такое же можно сделать и в JS (ECMAScrip6):

```js
[first, second, ...the_rest] = [1, 2, 3, 4];
// first === 1
// last === 2
// the_rest === [3, 4]
```
### Лямбда-функции

И Питон и JS имеют довольно ясную функциональность для создания однострочных функций. Такие функции называются лямбда-функциями. Лямбды это такие функции которые принимают один или более аргументов и возвращают вычисленное значение. Обычно лямбда-функции используются когда нужно передать одну функцию в другую функцию в качестве колбека или в случае когда необходимо обработать каждый элемент последовательности.


В Питоне можно определить лямбда-функцию используя ключевое слово `lambda`:

```Python
sum = lambda x, y: x + y
square = lambda x: x ** 2
```
В JS используется => нотация. Если аргументов больше одного, они помещаются в скобки:

```js
sum = (x, y) => x + y;
square = x => Math.pow(x, 2);
```
### Итерация без индексов

Многие ЯП позволяют обходить массивы только используя доступ к определенному элементу по номеру индекса и циклу с инкрементом этого индекса.

```js
for (i=0; i<items.length; i++) {
    console.log(items[i]);
}
```
Это не слишком красивая запись, и немного сложная для новичков — такая запись не выглядит естественно. В Питоне есть красивый лаконичный способ обхода списка:

```Python
for item in ['A', 'B', 'C']:
    print(item)
```
В современном JS такое реализуется при помощи оператора for..of:

```js
for (let item of ['A', 'B', 'C']) {
    console.log(item);
}
```
Также можно обойти строку посимвольно в Питоне:

```Python
for character in 'ABC':
    print(character)
```

И в современном JavaScript:

```js
for (let character of 'ABC') {
    console.log(character);
}
```
### Генераторы

И Питон и современный JS позволяют определить специальные функции которые будут выглядеть как итераторы. При каждом вызове (итерации) они будут возвращать следующее сгенерированное значение из последовательности. Такие функции называются генераторы.


Генераторы обычно используют чтобы получить: числа из диапазона, строки из файла, данные постранично из внешнего API, числа фибоначчи и другие динамически генерируемые последовательности.


Технически генераторы выглядят как обычные функции, но вместо того чтобы вернуть одно значение (и прекратить работу), они выдают одно значение и приостанавливают работу до следующего вызова. Они будут генерировать следующие значения из списка при каждом вызове пока не будет достигнут конец списка.


Рассмотрим пример на Питоне в котором создается генератор countdown() который возвращает числа от заданного числа до 1 в обратном порядке (10,9,8,...,1):

```Python
def countdown(counter):
    while counter > 0:
        yield counter
        counter -= 1

for counter in countdown(10):
    print(counter)
```
То же самое можно получить в современном JS, но обратите внимание на * в описании функции. Это определяет ее как генератор:

```js
function* countdown(counter) {
    while (counter > 0) {
        yield counter;
        counter--;
    }
}
for (let counter of countdown(10)) {
    console.log(counter);
}
```
### Множества (Sets)

Мы уже познакомились со списками (lists), кортежами (tuples), массивами (arrays). Но есть еще один тип данных — множества (sets). Множества это массивы данных в котором каждый уникальный элемент присутствует только в единственном экземпляре. Теория множеств определяет с множествами такие операции как объединение(union), пересечение(intersection), и разность(difference), но мы не будем сейчас их рассматривать.


Создаем множество, добавляем в него элемент, проверяем существование элемента, получаем общее количество элементов, обходим множество по элементам и удаляем один элемент используя Питон:

```Python
s = set(['A'])
s.add('B'); s.add('C')
'A' in s
len(s) == 3
for elem in s:
    print(elem)
s.remove('C')
```
То же самое на JS:

```js
s = new Set(['A']);
s.add('B').add('C');
s.has('A') === true;
s.size === 3;
for (let elem of s.values()) {
    console.log(elem);
}
s.delete('C')
```

### Аргументы функций

У Питона обширный инструментарий для работы с аргументами функций — есть значения по умолчанию, переменное число позиционных и именованных аргументов (`*args` и `**kwargs`).


Когда вы передаете значение в функцию, вы можете указать имя аргумента которому это значение будет передано. В JS тоже существует такая возможность.


Значения по умолчанию для аргументов функций могут быть определены в Питоне:

```Python
from pprint import pprint

def report(post_id, reason='not-relevant'):
    pprint({'post_id': post_id, 'reason': reason})

report(42)
report(post_id=24, reason='spam')
```
В JS аналогично:

```js
function report(post_id, reason='not-relevant') {
    console.log({post_id: post_id, reason: reason});
}

report(42);
report(post_id=24, reason='spam');
```
Позиционные аргументы в Питоне могут быть обработаны используя оператор `*`:

```Python
from pprint import pprint

def add_tags(post_id, *tags):
    pprint({'post_id': post_id, 'tags': tags})

add_tags(42, 'python', 'javascript', 'django')
```
В JS обработка позиционных аргументов происходит при помощи оператора ...:

```js
function add_tags(post_id, ...tags) {
    console.log({post_id: post_id, tags: tags});
}

add_tags(42, 'python', 'javascript', 'django');
```
Именованные аргументы часто применяются в Питоне когда необходимо передавать изменяемое число аргументов:

```Python
from pprint import pprint

def create_post(**options):
    pprint(options)

create_post(
    title='Hello, World!',
    content='This is our first post.',
    is_published=True,
)
create_post(
    title='Hello again!',
    content='This is our second post.',
)
```
Передача множества именованных аргументов в JS реализуется с помощью словаря (`options` в данном примере):

```js
function create_post(options) {
    console.log(options);
}

create_post({
    'title': 'Hello, World!',
    'content': 'This is our first post.',
    'is_published': true
});
create_post({
    'title': 'Hello again!',
    'content': 'This is our second post.'
});
```
### Классы и наследование

Питон — объектно-ориентированный язык. JS начиная с ECMAScript 6 также позволяет писать объектно-ориентированный код без всяких уловок и синтаксических оборотов.

Питон. Создаем класс, конструктор и метод для текстового представления объекта:

```Python
class Post(object):
    def __init__(self, id, title):
        self.id = id
        self.title = title

    def __str__(self):
        return self.title

post = Post(42, 'Hello, World!')
isinstance(post, Post) == True
print(post)  # Hello, World!
```
Аналогичные действия на JS:

```js
class Post {
    constructor (id, title) {
        this.id = id;
        this.title = title;
    }
    toString() {
        return this.title;
    }
}

post = new Post(42, 'Hello, World!');
post instanceof Post === true;
console.log(post.toString());  // Hello, World!
```
Создадим два класса `Article` и `Link` в Питоне, которые будут наследоваться от класса `Post`. Можно заметить, что мы используем функцию `super` для доступа к методам базового класса `Post`:

```Python
class Article(Post):
    def __init__(self, id, title, content):
        super(Article, self).__init__(id, title)
        self.content = content

class Link(Post):
    def __init__(self, id, title, url):
        super(Link, self).__init__(id, title)
        self.url = url

    def __str__(self):
        return '{} ({})'.format(
            super(Link, self).__str__(),
            self.url,
        )

article = Article(1, 'Hello, World!', 'This is my first article.')
link = Link(2, 'DjangoTricks', 'https://djangotricks.blogspot.com')
isinstance(article, Post) == True
isinstance(link, Post) == True
print(link)
# DjangoTricks (https://djangotricks.blogspot.com)
```
То же самое в JS:

```js
class Article extends Post {
    constructor (id, title, content) {
        super(id, title);
        this.content = content;
    }
}

class Link extends Post {
    constructor (id, title, url) {
        super(id, title);
        this.url = url;
    }
    toString() {
        return super.toString() + ' (' + this.url + ')';
    }
}

article = new Article(1, 'Hello, World!', 'This is my first article.');
link = new Link(2, 'DjangoTricks', 'https://djangotricks.blogspot.com');
article instanceof Post === true;
link instanceof Post === true;
console.log(link.toString());
// DjangoTricks (https://djangotricks.blogspot.com)
```
### Свойства класса: геттеры и сеттеры.

В объектно-ориентированном программировании у классов есть атрибуты, методы и свойства. Свойства — это смесь атрибутов и методов. Вы можете обращаться со свойствами как с атрибутами, но где-то внутри они вызывают специальные методы называемые геттерами и сеттерами (getters/setters) для специфической обработки данных.
В данном примере на Питоне показан базовый способ описания геттера и сеттера для свойства `slug` с помощью декораторов:

```Python
class Post(object):
    def __init__(self, id, title):
        self.id = id
        self.title = title
        self._slug = ''

    @property
    def slug(self):
        return self._slug

    @slug.setter
    def slug(self, value):
        self._slug = value

post = Post(1, 'Hello, World!')
post.slug = 'hello-world'
print(post.slug)
```
В JS геттер и сеттер для свойства slug могут быть описаны как:

```js
class Post {
    constructor (id, title) {
        this.id = id;
        this.title = title;
        this._slug = '';
    }

    set slug(value) {
        this._slug = value;
    }

    get slug() {
        return this._slug;
    }
}

post = new Post(1, 'Hello, World!');
post.slug = 'hello-world';
console.log(post.slug);
```
## Выводы

* Списки (lists) и кортежи (tuples) в Python соответствуют массивам (arrays) в Javascript.
* Словари (dictionaries) в Python соответствуют объектам (objects) в Javascript.

* Сериализация в/из JSON достаточно прямолинейна — что в Питоне что в JS.
* Регулярки — мощный инструмент обработки текстов в обоих языках.
* Можно производить замены с помощью функций.
* Для более сложных случаев можно использовать вызов, перехват и обработку ошибок.

* Строки в Питоне похожи на строки в Javascript.
* Приводить строку к числу в Javascript нужно с осторожностью, помня о системах счисления.
* Однострочные условные выражения существуют в обоих языках.
* Объединение последовательностей строк (' '.join) в Питоне обескураживает непосвященного в синтаксис, но к нему быстро привыкаешь.

* Строковые шаблоны (f-строки) позволяют улучшить читаемость и упростить код, даже в случае многострочных объектов.
* Можно обходить массивы, группы или строки без использования индексов.
* Используя генераторы можно получить последовательности с практически неограниченным числом элементов.
* Использование множеств упрощает проверку уникальности элемента в массиве.
* Используйте лямбды когда вам нужны небольшие однострочные функции.

* В обоих языках можно описать дефолтные значения у аргументов функций.
* В обоих языках можно передавать в функцию произвольное число именованных или позиционных аргументов.
* Оба языка поддерживают объектно-ориентированную парадигму программирования.


Используемые материалы:
[Первая часть](https://habr.com/post/416617/) — приведение к типу, тернарный оператор, доступ к свойству по имени свойства, словари, списки, строки, конкатенация строк.
[Вторая часть](https://habr.com/post/417513/) — сериализация словарей, JSON, регулярки, ошибки и исключения.
[Часть третья](https://habr.com/post/418191/): современные Python и JS: строковые шаблоны (f-строки), распаковка списков, лямбда-функции, итерации по спискам, генераторы, множества.
[Четвертая часть](https://habr.com/post/419271/) — аргументы функций, создание и работа с классами, наследование, геттеры-сеттеры и свойства класса.
