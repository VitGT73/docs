# Сравнительная таблица Python vs JS/TS vs Java



### Приведение к типу

Начнем с приведения строки к целому. В Питоне все просто и прямолинейно:


```number = int(text)```

Но в JS вы должны объяснить к какой системе вы собираетесь приводить — к десятеричной, восьмеричной, шестнадцатеричной или двоичной:


```js
number = parseInt(text, 10);
```

Для использования обычной десятеричной системы мы передаем 10 в виде второго аргумента функции parseInt(). 8 для восьмеричной, 16 для шестнадцатеричной или 2 — для двоичной. В случае если второй параметр опущен, число начинается с нуля и вы используете устаревший браузер, строка с текстом будет воспринята как восьмеричная система:

```js
parseInt('012') == 10  // в некоторых старых браузерах
parseInt('012', 10) == 12
```

### Условное присваивание

Хотя для этого Python и JS используют различный синтаксис, данная операция популярна в обоих языках. Популярна она потому, что в одном выражении можно присвоить различные значения как для True-, так и для False-случая.
Начиная с Python 2.7 условное присваивание выглядит так:


```value = 'YES' if positive == True else 'NO'```

В JavaScript условное присваивание производится с использованием тернарного оператора ?, также как в C, C++, C#, Java, Ruby, PHP, Perl, Swift, and ActionScript:


```js
value = positive === true? 'YES': 'NO';
```

### Доступ к свойству объекта по имени свойства

Обычный способ доступа к свойству объекта и в Python и в JS одинаковый:


```obj.color = 'YELLOW'```

А как быть если название свойства заключено в строчную переменную? К примеру, название свойства может быть получено из списка свойств или название свойства составлено из двух строковых переменных: ```"title" + land_code.```
В Питоне для этого существуют функции ``getattr()`` и ``setattr()``:


```Python
attribute = 'color'
value = getattr(obj, attribute, 'GREEN')
setattr(obj, attribute, value)
```

В JS вы можете обращаться с объектом как со словарем и передавать имя свойства в квадратных скобках:


```js
attribute = 'color';
value = obj[attribute] || 'GREEN';
obj[attribute] = value;
```

Чтобы получить значение по умолчанию в случае если свойства с таким именем не существует, в Питоне у функции `getattr()` есть для этого третий параметр. В JS, если запрашиваемое свойство отсутствует, функция вернет `undefined`. Его можно сравнить оператором `OR` со значением по дефолту – это стандартная практика в JS — такой способ можно встретить во многих фреймворках и библиотеках.


### Доступ к словарю по ключу

Схоже с вышеизложенным. Ключ стандартно указывается в квадратных скобках в обоих языках:


```Python
dictionary = {}
dictionary['color'] = 'YELLOW'
```

Для доступа по ключу в Питоне используется стандартный синтаксис с квадратными скобками, однако в случае если такой ключ отсутствует это вызовет исключение с ошибкой `KeyError`.
Более гибким является метод `get()` который вернет None в случае отсутствия ключа. Также можно передать значение которое будет возвращено в случае отсутствия ключа:

```Python
key = 'color'
value = dictionary.get(key, 'GREEN')
```

В JS вы можете проделать такой же трюк как со свойством объекта – `OR` со значением по дефолту:


```js
key = 'color';
value = dictionary[key] || 'GREEN';
```

### Срезы: списки и строки

У Питона есть оператор `[:]` получения части списка, кортежа или схожих структур. Пример с объектом типа `Django QuerySets`:


```Python
items = [1, 2, 3, 4, 5]
first_two = items[:2]      # [1, 2]
last_two = items[-2:]      # [4, 5]
middle_three = items[1:4]  # [2, 3, 4]
```

У JS есть метод `slice()` с тем же эффектом:


```js
items = [1, 2, 3, 4, 5];
first_two = items.slice(0, 2);     // [1, 2]
last_two = items.slice(-2);        // [4, 5]
middle_three = items.slice(1, 4);  // [2, 3, 4]
```

Но не путайте с методом `splice()` который изменяет исходный массив!


В Питоне оператор [:] также применим и к строкам:


```Python
text = 'ABCDE'
first_two = text[:2]      # 'AB'
last_two = text[-2:]      # 'DE'
middle_three = text[1:4]  # 'BCD'
```

В JS у строк также есть метод `slice()`:


```js
text = 'ABCDE';
first_two = text.slice(0, 2);    // 'AB'
last_two = text.slice(-2);       // 'DE'
middle_three = text.slice(1, 4); // 'BCD'
```

### Операции со списками

В программировании часто приходится собирать и анализировать последовательность элементов. В Питоне для этого обычно используют списки, а в Javascript — массивы. У них схожий синтаксис и операции, но различаются методы добавления и удаления элементов.


Соединяем два списка, добавляем один элемент в конец, добавляем один элемент в начало, получаем и удаляем элемент в начале, получаем и удаляем элемент с конца и удаляем конкретный элемент по индексу.

#### Python:


```Python
items1 = ['A']
items2 = ['B']
items = items1 + items2  # items == ['A', 'B']
items.append('C')        # ['A', 'B', 'C']
items.insert(0, 'D')     # ['D', 'A', 'B', 'C']
first = items.pop(0)     # ['A', 'B', 'C']
last = items.pop()       # ['A', 'B']
items.delete(0)          # ['B']
```

#### То же в Javascript:


```js
items1 = ['A'];
items2 = ['B'];
items = items1.concat(items2);  // items === ['A', 'B']
items.push('C');                // ['A', 'B', 'C']
items.unshift('D');             // ['D', 'A', 'B', 'C']
first = items.shift();          // ['A', 'B', 'C']
last = items.pop();             // ['A', 'B']
items.splice(0, 1);             // ['B']
```

### Соединяем наборы строк

Соединить набор строковых элементов в единую строку используя пробел, запятую или перевод строки в виде соединительного символа.


В Питоне для этого служит строковый метод join() который принимает в виде аргумента список или кортеж. Для непосвященного (в синтаксис Питона) может показаться странным начинать выражение с разделителя, но, после регулярного применения вы привыкнете к такой форме записи:


```Python
items = ['A', 'B', 'C']
text = ', '.join(items)  # 'A, B, C'
```

В JS у массивов есть метод `join()` с разделителем в виде аргумента:


```js
items = ['A', 'B', 'C'];
text = items.join(', ');  // 'A, B, C'
```
Переменные в строках

Традиционный способ построения строк с переменными использует конкатенацию строк и переменных:


name = 'World'
value = 'Hello, ' + name + '!\nWelcome!'

Такая запись может показаться разбросанной и плохочитаемой, также часто можно ошибиться в пробелах окружающих слова в строках.


Начиная с версии 3.6 в Питоне и в JS ECMAScrip6 вы можете использовать строковую интерполяцию, или, в терминах Питона — f-строки. Это строковые шаблоны в которых подставляются значения из переменных.


В Питоне f-строки помечаются символом f перед кавычками:


name = 'World'
value = f"""Hello, {name}!
Welcome!"""

price = 14.9
value = f'Price: {price:.2f} €'  # 'Price: 14.90 €'

В JS строковые шаблоны начинаются и кончаются обратной кавычкой (backtrick) `


name = 'World';
value = `Hello, ${name}!
Welcome!`;

price = 14.9;
value = `Price ${price.toFixed(2)} €`;  // 'Price: 14.90 €'

Заметим, что шаблоны могут быть как одно- итак и многострочными.
В Питоне можно задать форматирование переменных.


Распаковка списков

В Питоне, а теперь уже и в JS существует интересная возможность присвоить элементы последовательности различным переменным. К примеру, мы можем присвоить трем переменным три значения из списка:


[a, b, c] = [1, 2, 3]

Для кортежей скобки могут быть опущены.
Следующий пример очень популярен в Питоне как способ обмена значений двух переменных:


a = 1
b = 2
a, b = b, a   # поменяли значения

В JS6+ также возможно:


a = 1;
b = 2;
[a, b] = [b, a];  // поменяли значения

В Питоне, в случае если у нас есть неопределенное количество элементов в списке или кортеже, мы можем присвоить эти элементы кортежу из переменных в котором последние несколько значений вернуться как список:


first, second, *the_rest = [1, 2, 3, 4]
# first == 1
# second == 2
# the_rest == [3, 4]

Такое же можно сделать и в JS (ECMAScrip6):


[first, second, ...the_rest] = [1, 2, 3, 4];
// first === 1
// last === 2
// the_rest === [3, 4]

Лямбда-функции

И Питон и JS имеют довольно ясную функциональность для создания однострочных функций. Такие функции называются лямбда-функциями. Лямбды это такие функции которые принимают один или более аргументов и возвращают вычисленное значение. Обычно лямбда-функции используются когда нужно передать одну функцию в другую функцию в качестве колбека или в случае когда необходимо обработать каждый элемент последовательности.


В Питоне можно определить лямбда-функцию используя ключевое слово lambda:


sum = lambda x, y: x + y
square = lambda x: x ** 2

В JS используется => нотация. Если аргументов больше одного, они помещаются в скобки:


sum = (x, y) => x + y;
square = x => Math.pow(x, 2);

Итерация без индексов

Многие ЯП позволяют обходить массивы только используя доступ к определенному элементу по номеру индекса и циклу с инкрементом этого индекса.


for (i=0; i<items.length; i++) {
    console.log(items[i]);
}

Это не слишком красивая запись, и немного сложная для новичков — такая запись не выглядит естественно. В Питоне есть красивый лаконичный способ обхода списка:


for item in ['A', 'B', 'C']:
    print(item)

В современном JS такое реализуется при помощи оператора for..of:


for (let item of ['A', 'B', 'C']) {
    console.log(item);
}

Также можно обойти строку посимвольно в Питоне:


for character in 'ABC':
    print(character)

И в современном JavaScript:


for (let character of 'ABC') {
    console.log(character);
}

Генераторы

И Питон и современный JS позволяют определить специальные функции которые будут выглядеть как итераторы. При каждом вызове (итерации) они будут возвращать следующее сгенерированное значение из последовательности. Такие функции называются генераторы.


Генераторы обычно используют чтобы получить: числа из диапазона, строки из файла, данные постранично из внешнего API, числа фибоначчи и другие динамически генерируемые последовательности.


Технически генераторы выглядят как обычные функции, но вместо того чтобы вернуть одно значение (и прекратить работу), они выдают одно значение и приостанавливают работу до следующего вызова. Они будут генерировать следующие значения из списка при каждом вызове пока не будет достигнут конец списка.


Рассмотрим пример на Питоне в котором создается генератор countdown() который возвращает числа от заданного числа до 1 в обратном порядке (10,9,8,...,1):


def countdown(counter):
    while counter > 0:
        yield counter
        counter -= 1

for counter in countdown(10):
    print(counter)

То же самое можно получить в современном JS, но обратите внимание на * в описании функции. Это определяет ее как генератор:


function* countdown(counter) {
    while (counter > 0) {
        yield counter;
        counter--;
    }
}
for (let counter of countdown(10)) {
    console.log(counter);
}

Множества (Sets)

Мы уже познакомились со списками (lists), кортежами (tuples), массивами (arrays). Но есть еще один тип данных — множества (sets). Множества это массивы данных в котором каждый уникальный элемент присутствует только в единственном экземпляре. Теория множеств определяет с множествами такие операции как объединение(union), пересечение(intersection), и разность(difference), но мы не будем сейчас их рассматривать.


Создаем множество, добавляем в него элемент, проверяем существование элемента, получаем общее количество элементов, обходим множество по элементам и удаляем один элемент используя Питон:


s = set(['A'])
s.add('B'); s.add('C')
'A' in s
len(s) == 3
for elem in s:
    print(elem)
s.remove('C')

То же самое на JS:


s = new Set(['A']);
s.add('B').add('C');
s.has('A') === true;
s.size === 3;
for (let elem of s.values()) {
    console.log(elem);
}
s.delete('C')

Подытожим






Подытожим

* Списки (lists) и кортежи (tuples) в Python соответствуют массивам (arrays) в Javascript.
* Словари (dictionaries) в Python соответствуют объектам (objects) в Javascript.
* Строки в Питоне похожи на строки в Javascript.
* Приводить строку к числу в Javascript нужно с осторожностью, помня о системах счисления.
* Однострочные условные выражения существуют в обоих языках.
* Объединение последовательностей строк (' '.join) в Питоне обескураживает непосвященного в синтаксис, но к нему быстро привыкаешь.

* Строковые шаблоны (f-строки) позволяют улучшить читаемость и упростить код, даже в случае многострочных объектов.
* Можно обходить массивы, группы или строки без использования индексов.
* Используя генераторы можно получить последовательности с практически неограниченным числом элементов.
* Использование множеств упрощает проверку уникальности элемента в массиве.
* Используйте лямбды когда вам нужны небольшие однострочные функции.

Используемые материалы:
[Первая часть](https://habr.com/post/416617/) — приведение к типу, тернарный оператор, доступ к свойству по имени свойства, словари, списки, строки, конкатенация строк.
[Вторая часть](https://habr.com/post/417513/) — сериализация словарей, JSON, регулярки, ошибки и исключения.
[Часть третья](https://habr.com/post/418191/): современные Python и JS: строковые шаблоны (f-строки), распаковка списков, лямбда-функции, итерации по спискам, генераторы, множества.
[Четвертая часть](https://habr.com/post/419271/) — аргументы функций, создание и работа с классами, наследование, геттеры-сеттеры и свойства класса.
